0907-31  
:guardsman: Сакаева Диана  
:smiley_cat: Загидуллина Камила  
:ok_woman: Шамуранова Елизавета  
  
# File project

## Подключение к проекту

Чтобы подключить функциональность файловой системы к проекту, выполните следующие шаги:

1. Скачайте файлы библиотеки: Убедитесь, что у вас есть файлы filesystem.c и filesystem.h.

2. Расположите файлы в проекте: Поместите filesystem.c в папку с исходным кодом вашего проекта, а filesystem.h — в директорию, где состоят ваши заголовочные файлы или в ту же директорию, что и filesystem.c.

3. Подключите заголовочный файл: Добавьте включение заголовочного файла в ваши исходные файлы, где вы планируете использовать функциональность библиотеки. Это можно сделать с помощью директивы #include.

#include "filesystem.h"

4. Скомпилируйте проект: Убедитесь, что ваш проект компилируется с включением файла filesystem.c. Если вы используете командную строку для компиляции, убедитесь, что filesystem.c добавлен в список исходных файлов. Если вы используете среду разработки (IDE), добавьте filesystem.c в ваш проект через интерфейс IDE.

gcc -o my_program main.c filesystem.c

5. Используйте функции библиотеки: Вы теперь готовы использовать функции из filesystem.c в коде вашего проекта.

# 1 Задание. Создание filesystem.c

## 1. Функция для поиска индекса файла в файловой системе

## find_index
- **Параметры**:
  - `fs`: 
    - Тип: `const FileSystem *`
    - Описание: Указатель на структуру `FileSystem`, которая содержит информацию о файлах в файловой системе. Используется для поиска файла по указанному пути.
  - `path`: 
    - Тип: `const char *`
    - Описание: Строка, представляющая путь к файлу. Функция будет сравнивать этот путь с путями файлов в файловой системе.

- **Возвращает**:
  - Тип: `int`
  - Описание: Индекс файла в массиве `entries` структуры `FileSystem`. Если файл не найден, возвращает -1.
  
```
static int find_index(const FileSystem *fs, const char *path) {
    for (size_t i = 0; i < fs->count; ++i)
        if (strcmp(fs->entries[i].path, path) == 0)
            return (int)i;
    return -1;
}  
```  

## 2. Функция открытия файла

## fs_load
- **Параметры**:
  - `fname`: 
    - Тип: `const char *`
    - Описание: Имя файла, который нужно открыть и загрузить в файловую систему. Это путь к файлу на диске.
  - `fs`: 
    - Тип: `FileSystem *`
    - Описание: Указатель на структуру `FileSystem`, в которую будут записаны данные загружаемого файла.

- **Возвращает**:
  - Тип: `int`
  - Описание: 
    - Возвращает 1, если файл успешно открыт и данные загружены.
    - Возвращает 0, если произошла ошибка при открытии файла (например, файл не найден). 

  
```
int fs_load(const char *fname, FileSystem *fs) {
    FILE *f = fopen(fname, "r");
    if (!f) {                        
        fs->entries = NULL;
        fs->count = 0;
        return 0;
}  
```
## 3. Функция для добавления нового элемента (файла) в файловую систему. 
## fs_insert


**Параметры** 
- FileSystem *fs: указатель на структуру файловой системы, куда будет добавлен новый элемент. Тип данных: указатель на FileSystem.
- const char *path: строка, представляющая путь к новому элементу, который добавляется в файловую систему. Тип данных: указатель на char.

**Возвращаемое значение**
- Возвращает 0 в случае успешного добавления нового элемента.
- Возвращает -1, если элемент с указанным путем уже существует или при возникновении ошибки выделения памяти. Тип данных: int.
```
int fs_insert(FileSystem *fs, const char *path) {
    if (find_index(fs, path) >= 0) return -1;    

    FileEntry *tmp = realloc(fs->entries, (fs->count + 1) * sizeof *tmp);
    if (!tmp) return -1;
    fs->entries = tmp;

    fs->entries[fs->count].path = strdup(path);
    fs->entries[fs->count].content = strdup("");
    fs->count++;
    return 0;
}  
```  
 ## 4. Функция для обновления содержимого существующего файла в файловой системе. 
 ## fs_update  
  
**Параметры**    
- FileSystem *fs: указатель на структуру файловой системы, в которой содержится обновляемый файл. Тип данных: указатель на FileSystem.    
- const char *path: строка, представляющая путь к файлу, содержимое которого должно быть обновлено. Тип данных: указатель на char.   
- const char *new_content: строка с новым содержимым для указанного файла. Тип данных: указатель на char.  
  
**Возвращаемое значение**  
- Возвращает 0 в случае успешного обновления содержимого файла.
- Возвращает -1, если файл с указанным путем не найден. Тип данных: int.  
  
```
int fs_update(FileSystem *fs, const char *path, const char *new_content) {
    int idx = find_index(fs, path);
    if (idx < 0) return -1;
    free(fs->entries[idx].content);
    fs->entries[idx].content = strdup(new_content);
    return 0;
}
```
## 5. Код для удаления файла

## fs_delete
- **Параметры**:
  - `fs`: 
    - Тип: `FileSystem *`
    - Описание: Указатель на структуру `FileSystem`, из которой необходимо удалить файл. Этот указатель используется для модификации структуры файловой системы.
  - `path`: 
    - Тип: `const char *`
    - Описание: Строка, представляющая путь к файлу, который нужно удалить из файловой системы.

- **Возвращает**:
  - Тип: `int`
  - Описание:
    - Возвращает 0, если файл удален успешно.
    - Возвращает -1, если файл не найден, и, соответственно, не может быть удален.


```
int fs_delete(FileSystem *fs, const char *path) {
    int idx = find_index(fs, path);
    if (idx < 0) return -1;
    free(fs->entries[idx].path);
    free(fs->entries[idx].content);
    memmove(&fs->entries[idx], &fs->entries[idx + 1],
            (fs->count - idx - 1) * sizeof(FileEntry));
    fs->count--;
    return 0;
}  
```
## Принцип использования команд
```
> INSERT /hello.txt
Готово
> UPDATE /hello.txt
Введите новые данные (строка "." завершает ввод):
Привет, мир!
.
Перезаписано
> COUNT
1
> CRYPTO /hello.txt mykey
Зашифровано
> DECRYPTO /hello.txt mykey
Расшифровано
> RENAME /hello.txt /docs/hello.txt
Переименовано
> EXIT
Изменения сохранены. Пока!
```
